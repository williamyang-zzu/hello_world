"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_test_1 = require("node:test");
const index_1 = require("./index");
const web3_js_1 = require("@solana/web3.js");
const strict_1 = __importDefault(require("node:assert/strict"));
const bs58_1 = __importDefault(require("bs58"));
// See https://m.media-amazon.com/images/I/51TJeGHxyTL._SY445_SX342_.jpg
const child_process_1 = require("child_process");
const util_1 = require("util");
const promises_1 = require("node:fs/promises");
const dotenv_1 = __importDefault(require("dotenv"));
const spl_token_1 = require("@solana/spl-token");
const exec = (0, util_1.promisify)(child_process_1.exec);
const LOCALHOST = "http://127.0.0.1:8899";
const MEMO_PROGRAM_ID = new web3_js_1.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
const TEMP_DIR = "src/temp";
(0, node_test_1.describe)(`getCustomErrorMessage`, () => {
    (0, node_test_1.test)(`we turn error messages with hex codes into error messages for the program`, () => {
        // This example set of error is from the token program
        // https://github.com/solana-labs/solana-program-library/blob/master/token/program/src/error.rs
        const programErrors = [
            "Lamport balance below rent-exempt threshold",
            "Insufficient funds",
            "Invalid Mint",
            "Account not associated with this Mint",
            "Owner does not match",
            "Fixed supply",
            "Already in use",
            "Invalid number of provided signers",
            "Invalid number of required signers",
            "State is unititialized",
            "Instruction does not support native tokens",
            "Non-native account can only be closed if its balance is zero",
            "Invalid instruction",
            "State is invalid for requested operation",
            "Operation overflowed",
            "Account does not support specified authority type",
            "This token mint cannot freeze accounts",
            "Account is frozen",
            "The provided decimals value different from the Mint decimals",
            "Instruction does not support non-native tokens",
        ];
        const errorMessage = (0, index_1.getCustomErrorMessage)(programErrors, "failed to send transaction: Transaction simulation failed: Error processing Instruction 0: custom program error: 0x10");
        strict_1.default.equal(errorMessage, "This token mint cannot freeze accounts");
    });
});
(0, node_test_1.describe)("getKeypairFromFile", () => {
    let TEST_FILE_NAME = `${TEMP_DIR}/test-keyfile-do-not-use.json`;
    let MISSING_FILE_NAME = "THIS FILE DOES NOT EXIST";
    let CORRUPT_TEST_FILE_NAME = `${TEMP_DIR}/corrupt-keyfile-do-not-use.json`;
    (0, node_test_1.before)(async () => {
        const { stdout } = await exec(`solana-keygen new --force --no-bip39-passphrase -o ${TEST_FILE_NAME}`);
        (0, strict_1.default)(stdout.includes("Wrote new keypair"));
        await (0, promises_1.writeFile)(CORRUPT_TEST_FILE_NAME, "I AM CORRUPT");
    });
    (0, node_test_1.test)("getting a keypair from a file", async () => {
        await (0, index_1.getKeypairFromFile)(TEST_FILE_NAME);
    });
    (0, node_test_1.test)("throws a nice error if the file is missing", async () => {
        strict_1.default.rejects(async () => await (0, index_1.getKeypairFromFile)(MISSING_FILE_NAME), {
            message: `Could not read keypair from file at '${MISSING_FILE_NAME}'`,
        });
    });
    (0, node_test_1.test)("throws a nice error if the file is corrupt", async () => {
        strict_1.default.rejects(() => (0, index_1.getKeypairFromFile)(CORRUPT_TEST_FILE_NAME), {
            message: `Invalid secret key file at '${CORRUPT_TEST_FILE_NAME}'!`,
        });
    });
});
(0, node_test_1.describe)("getKeypairFromEnvironment", () => {
    let TEST_ENV_VAR_ARRAY_OF_NUMBERS = "TEST_ENV_VAR_ARRAY_OF_NUMBERS";
    let TEST_ENV_VAR_BASE58 = "TEST_ENV_VAR_BASE58";
    let TEST_ENV_VAR_WITH_BAD_VALUE = "TEST_ENV_VAR_WITH_BAD_VALUE";
    (0, node_test_1.before)(async () => {
        const randomKeypair = web3_js_1.Keypair.generate();
        process.env[TEST_ENV_VAR_ARRAY_OF_NUMBERS] = JSON.stringify(Object.values(randomKeypair.secretKey));
        process.env[TEST_ENV_VAR_BASE58] = bs58_1.default.encode(randomKeypair.secretKey);
        process.env[TEST_ENV_VAR_WITH_BAD_VALUE] =
            "this isn't a valid value for a secret key";
    });
    (0, node_test_1.test)("getting a keypair from an environment variable (array of numbers format)", async () => {
        await (0, index_1.getKeypairFromEnvironment)(TEST_ENV_VAR_ARRAY_OF_NUMBERS);
    });
    (0, node_test_1.test)("getting a keypair from an environment variable (base58 format)", async () => {
        await (0, index_1.getKeypairFromEnvironment)(TEST_ENV_VAR_BASE58);
    });
    (0, node_test_1.test)("throws a nice error if the env var doesn't exist", () => {
        strict_1.default.throws(() => (0, index_1.getKeypairFromEnvironment)("MISSING_ENV_VAR"), {
            message: `Please set 'MISSING_ENV_VAR' in environment.`,
        });
    });
    (0, node_test_1.test)("throws a nice error if the value of the env var isn't valid", () => {
        strict_1.default.throws(() => (0, index_1.getKeypairFromEnvironment)("TEST_ENV_VAR_WITH_BAD_VALUE"), {
            message: `Invalid secret key in environment variable 'TEST_ENV_VAR_WITH_BAD_VALUE'!`,
        });
    });
});
(0, node_test_1.describe)("addKeypairToEnvFile", () => {
    let TEST_ENV_VAR_ARRAY_OF_NUMBERS = "TEST_ENV_VAR_ARRAY_OF_NUMBERS";
    let testKeypair;
    (0, node_test_1.before)(async () => {
        testKeypair = web3_js_1.Keypair.generate();
        process.env[TEST_ENV_VAR_ARRAY_OF_NUMBERS] = JSON.stringify(Object.values(testKeypair.secretKey));
    });
    (0, node_test_1.test)("generates new keypair and writes to env if variable doesn't exist", async () => {
        // We need to use a specific file name to avoid conflicts with other tests
        const envFileName = ".env-unittest-addkeypairtoenvfile";
        await (0, index_1.addKeypairToEnvFile)(testKeypair, "TEMP_KEYPAIR", envFileName);
        // Now reload the environment and check it matches our test keypair
        dotenv_1.default.config({ path: envFileName });
        // Get the secret from the .env file
        const secretKeyString = process.env["TEMP_KEYPAIR"];
        if (!secretKeyString) {
            throw new Error("TEMP_KEYPAIR not found in environment");
        }
        const decodedSecretKey = Uint8Array.from(JSON.parse(secretKeyString));
        const envKeypair = web3_js_1.Keypair.fromSecretKey(decodedSecretKey);
        strict_1.default.ok(envKeypair.secretKey);
        await (0, promises_1.unlink)(envFileName);
    });
    (0, node_test_1.test)("throws a nice error if the env var already exists", async () => {
        strict_1.default.rejects(async () => (0, index_1.addKeypairToEnvFile)(testKeypair, TEST_ENV_VAR_ARRAY_OF_NUMBERS), {
            message: `'TEST_ENV_VAR_ARRAY_OF_NUMBERS' already exists in env file.`,
        });
    });
});
(0, node_test_1.describe)("initializeKeypair", () => {
    const connection = new web3_js_1.Connection(LOCALHOST);
    const keypairVariableName = "INITIALIZE_KEYPAIR_TEST";
    (0, node_test_1.test)("generates a new keypair and airdrops needed amount", async () => {
        // We need to use a specific file name to avoid conflicts with other tests
        const envFileName = ".env-unittest-initkeypair";
        const options = {
            envFileName,
            envVariableName: keypairVariableName,
        };
        const signerFirstLoad = await (0, index_1.initializeKeypair)(connection, options);
        // Check balance
        const firstBalanceLoad = await connection.getBalance(signerFirstLoad.publicKey);
        strict_1.default.ok(firstBalanceLoad > 0);
        // Check that the environment variable was created
        dotenv_1.default.config({ path: envFileName });
        const secretKeyString = process.env[keypairVariableName];
        if (!secretKeyString) {
            throw new Error(`${secretKeyString} not found in environment`);
        }
        // Now reload the environment and check it matches our test keypair
        const signerSecondLoad = await (0, index_1.initializeKeypair)(connection, options);
        // Check the keypair is the same
        strict_1.default.ok(signerFirstLoad.publicKey.equals(signerSecondLoad.publicKey));
        // Check balance has not changed
        const secondBalanceLoad = await connection.getBalance(signerSecondLoad.publicKey);
        strict_1.default.equal(firstBalanceLoad, secondBalanceLoad);
        // Check there is a secret key
        strict_1.default.ok(signerSecondLoad.secretKey);
        await (0, promises_1.unlink)(envFileName);
    });
});
(0, node_test_1.describe)("airdropIfRequired", () => {
    (0, node_test_1.test)("Checking the balance after airdropIfRequired", async () => {
        const keypair = web3_js_1.Keypair.generate();
        const connection = new web3_js_1.Connection(LOCALHOST);
        const originalBalance = await connection.getBalance(keypair.publicKey);
        strict_1.default.equal(originalBalance, 0);
        const lamportsToAirdrop = 1 * web3_js_1.LAMPORTS_PER_SOL;
        const newBalance = await (0, index_1.airdropIfRequired)(connection, keypair.publicKey, lamportsToAirdrop, 1 * web3_js_1.LAMPORTS_PER_SOL);
        strict_1.default.equal(newBalance, lamportsToAirdrop);
        const recipient = web3_js_1.Keypair.generate();
        // Spend our SOL now to ensure we can use the airdrop immediately
        await connection.sendTransaction(new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
            fromPubkey: keypair.publicKey,
            toPubkey: recipient.publicKey,
            lamports: 500000000,
        })), [keypair]);
    });
    (0, node_test_1.test)("doesn't request unnecessary airdrops", async () => {
        const keypair = web3_js_1.Keypair.generate();
        const connection = new web3_js_1.Connection(LOCALHOST);
        const originalBalance = await connection.getBalance(keypair.publicKey);
        strict_1.default.equal(originalBalance, 0);
        const lamportsToAirdrop = 1 * web3_js_1.LAMPORTS_PER_SOL;
        await (0, index_1.airdropIfRequired)(connection, keypair.publicKey, lamportsToAirdrop, 500000);
        const finalBalance = await (0, index_1.airdropIfRequired)(connection, keypair.publicKey, lamportsToAirdrop, 1 * web3_js_1.LAMPORTS_PER_SOL);
        // Check second airdrop didn't happen (since we only had 1 sol)
        strict_1.default.equal(finalBalance, 1 * lamportsToAirdrop);
    });
    (0, node_test_1.test)("airdropIfRequired does airdrop when necessary", async () => {
        const keypair = web3_js_1.Keypair.generate();
        const connection = new web3_js_1.Connection(LOCALHOST);
        const originalBalance = await connection.getBalance(keypair.publicKey);
        strict_1.default.equal(originalBalance, 0);
        // Get 999_999_999 lamports if we have less than 500_000 lamports
        const lamportsToAirdrop = 1 * web3_js_1.LAMPORTS_PER_SOL - 1;
        await (0, index_1.airdropIfRequired)(connection, keypair.publicKey, lamportsToAirdrop, 500000);
        // We only have 999_999_999 lamports, so we should need another airdrop
        const finalBalance = await (0, index_1.airdropIfRequired)(connection, keypair.publicKey, 1 * web3_js_1.LAMPORTS_PER_SOL, 1 * web3_js_1.LAMPORTS_PER_SOL);
        // Check second airdrop happened
        strict_1.default.equal(finalBalance, 2 * web3_js_1.LAMPORTS_PER_SOL - 1);
    });
});
(0, node_test_1.describe)("getExplorerLink", () => {
    (0, node_test_1.test)("getExplorerLink works for a block on mainnet", () => {
        const link = (0, index_1.getExplorerLink)("block", "242233124", "mainnet-beta");
        strict_1.default.equal(link, "https://explorer.solana.com/block/242233124");
    });
    (0, node_test_1.test)("getExplorerLink works for a block on mainnet when no network is supplied", () => {
        const link = (0, index_1.getExplorerLink)("block", "242233124");
        strict_1.default.equal(link, "https://explorer.solana.com/block/242233124");
    });
    (0, node_test_1.test)("getExplorerLink works for an address on mainnet", () => {
        const link = (0, index_1.getExplorerLink)("address", "dDCQNnDmNbFVi8cQhKAgXhyhXeJ625tvwsunRyRc7c8", "mainnet-beta");
        strict_1.default.equal(link, "https://explorer.solana.com/address/dDCQNnDmNbFVi8cQhKAgXhyhXeJ625tvwsunRyRc7c8");
    });
    (0, node_test_1.test)("getExplorerLink works for an address on devnet", () => {
        const link = (0, index_1.getExplorerLink)("address", "dDCQNnDmNbFVi8cQhKAgXhyhXeJ625tvwsunRyRc7c8", "devnet");
        strict_1.default.equal(link, "https://explorer.solana.com/address/dDCQNnDmNbFVi8cQhKAgXhyhXeJ625tvwsunRyRc7c8?cluster=devnet");
    });
    (0, node_test_1.test)("getExplorerLink works for a transaction on mainnet", () => {
        const link = (0, index_1.getExplorerLink)("transaction", "4nzNU7YxPtPsVzeg16oaZvLz4jMPtbAzavDfEFmemHNv93iYXKKYAaqBJzFCwEVxiULqTYYrbjPwQnA1d9ZCTELg", "mainnet-beta");
        strict_1.default.equal(link, "https://explorer.solana.com/tx/4nzNU7YxPtPsVzeg16oaZvLz4jMPtbAzavDfEFmemHNv93iYXKKYAaqBJzFCwEVxiULqTYYrbjPwQnA1d9ZCTELg");
    });
    (0, node_test_1.test)("getExplorerLink works for a block on mainnet", () => {
        const link = (0, index_1.getExplorerLink)("block", "241889720", "mainnet-beta");
        strict_1.default.equal(link, "https://explorer.solana.com/block/241889720");
    });
    (0, node_test_1.test)("getExplorerLink provides a localnet URL", () => {
        const link = (0, index_1.getExplorerLink)("tx", "2QC8BkDVZgaPHUXG9HuPw7aE5d6kN5DTRXLe2inT1NzurkYTCFhraSEo883CPNe18BZ2peJC1x1nojZ5Jmhs94pL", "localnet");
        strict_1.default.equal(link, "https://explorer.solana.com/tx/2QC8BkDVZgaPHUXG9HuPw7aE5d6kN5DTRXLe2inT1NzurkYTCFhraSEo883CPNe18BZ2peJC1x1nojZ5Jmhs94pL?cluster=custom&customUrl=http%3A%2F%2Flocalhost%3A8899");
    });
});
(0, node_test_1.describe)("makeKeypairs", () => {
    (0, node_test_1.test)("makeKeypairs makes exactly the amount of keypairs requested", () => {
        // We could test more, but keypair generation takes time and slows down tests
        const KEYPAIRS_TO_MAKE = 3;
        const keypairs = (0, index_1.makeKeypairs)(KEYPAIRS_TO_MAKE);
        strict_1.default.equal(keypairs.length, KEYPAIRS_TO_MAKE);
        strict_1.default.ok(keypairs[KEYPAIRS_TO_MAKE - 1].secretKey);
    });
    (0, node_test_1.test)("makeKeypairs() creates the correct number of keypairs", () => {
        const keypairs = (0, index_1.makeKeypairs)(3);
        strict_1.default.equal(keypairs.length, 3);
    });
});
(0, node_test_1.describe)("confirmTransaction", () => {
    (0, node_test_1.test)("confirmTransaction works for a successful transaction", async () => {
        const connection = new web3_js_1.Connection(LOCALHOST);
        const [sender, recipient] = [web3_js_1.Keypair.generate(), web3_js_1.Keypair.generate()];
        const lamportsToAirdrop = 2 * web3_js_1.LAMPORTS_PER_SOL;
        await (0, index_1.airdropIfRequired)(connection, sender.publicKey, lamportsToAirdrop, 1 * web3_js_1.LAMPORTS_PER_SOL);
        const transaction = await connection.sendTransaction(new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
            fromPubkey: sender.publicKey,
            toPubkey: recipient.publicKey,
            lamports: 1000000,
        })), [sender]);
        await (0, index_1.confirmTransaction)(connection, transaction);
    });
});
(0, node_test_1.describe)(`getLogs`, () => {
    (0, node_test_1.test)(`getLogs works`, async () => {
        const connection = new web3_js_1.Connection(LOCALHOST);
        const [sender, recipient] = [web3_js_1.Keypair.generate(), web3_js_1.Keypair.generate()];
        const lamportsToAirdrop = 2 * web3_js_1.LAMPORTS_PER_SOL;
        await (0, index_1.airdropIfRequired)(connection, sender.publicKey, lamportsToAirdrop, 1 * web3_js_1.LAMPORTS_PER_SOL);
        const transaction = await connection.sendTransaction(new web3_js_1.Transaction().add(web3_js_1.SystemProgram.transfer({
            fromPubkey: sender.publicKey,
            toPubkey: recipient.publicKey,
            lamports: 1000000,
        })), [sender]);
        const logs = await (0, index_1.getLogs)(connection, transaction);
        strict_1.default.deepEqual(logs, [
            "Program 11111111111111111111111111111111 invoke [1]",
            "Program 11111111111111111111111111111111 success",
        ]);
    });
});
(0, node_test_1.describe)("getSimulationComputeUnits", () => {
    (0, node_test_1.test)("getSimulationComputeUnits returns 300 CUs for a SOL transfer, and 3888 for a SOL transfer with a memo", async () => {
        const connection = new web3_js_1.Connection(LOCALHOST);
        const sender = web3_js_1.Keypair.generate();
        await (0, index_1.airdropIfRequired)(connection, sender.publicKey, 1 * web3_js_1.LAMPORTS_PER_SOL, 1 * web3_js_1.LAMPORTS_PER_SOL);
        const recipient = web3_js_1.Keypair.generate().publicKey;
        const sendSol = web3_js_1.SystemProgram.transfer({
            fromPubkey: sender.publicKey,
            toPubkey: recipient,
            lamports: 1000000,
        });
        const sayThanks = new web3_js_1.TransactionInstruction({
            keys: [],
            programId: MEMO_PROGRAM_ID,
            data: Buffer.from("thanks"),
        });
        const computeUnitsSendSol = await (0, index_1.getSimulationComputeUnits)(connection, [sendSol], sender.publicKey, []);
        // TODO: it would be useful to have a breakdown of exactly how 300 CUs is calculated
        strict_1.default.equal(computeUnitsSendSol, 300);
        const computeUnitsSendSolAndSayThanks = await (0, index_1.getSimulationComputeUnits)(connection, [sendSol, sayThanks], sender.publicKey, []);
        // TODO: it would be useful to have a breakdown of exactly how 3888 CUs is calculated
        // also worth reviewing why memo program seems to use so many CUs.
        strict_1.default.equal(computeUnitsSendSolAndSayThanks, 3888);
    });
});
(0, node_test_1.describe)("makeTokenMint", () => {
    (0, node_test_1.test)("makeTokenMint makes a new mint with the specified metadata", async () => {
        var _a;
        const mintAuthority = web3_js_1.Keypair.generate();
        const connection = new web3_js_1.Connection(LOCALHOST);
        await (0, index_1.airdropIfRequired)(connection, mintAuthority.publicKey, 100 * web3_js_1.LAMPORTS_PER_SOL, 1 * web3_js_1.LAMPORTS_PER_SOL);
        const name = "Unit test token";
        const symbol = "TEST";
        const decimals = 9;
        const uri = "https://example.com";
        const additionalMetadata = {
            shlerm: "frobular",
            glerp: "flerpy",
            gurperderp: "erpy",
            nurmagerd: "flerpy",
            zurp: "flerpy",
            eruper: "flerpy",
            zerperurperserp: "flerpy",
            zherp: "flerpy",
        };
        const mintAddress = await (0, index_1.makeTokenMint)(connection, mintAuthority, name, symbol, decimals, uri, additionalMetadata);
        strict_1.default.ok(mintAddress);
        const tokenMetadata = await (0, spl_token_1.getTokenMetadata)(connection, mintAddress);
        if (!tokenMetadata) {
            throw new Error(`Token metadata not found for mint address ${mintAddress}`);
        }
        strict_1.default.equal(tokenMetadata.mint.toBase58(), mintAddress.toBase58());
        strict_1.default.equal((_a = tokenMetadata.updateAuthority) === null || _a === void 0 ? void 0 : _a.toBase58(), mintAuthority.publicKey.toBase58());
        strict_1.default.equal(tokenMetadata.name, name);
        strict_1.default.equal(tokenMetadata.symbol, symbol);
        strict_1.default.equal(tokenMetadata.uri, uri);
        strict_1.default.deepEqual(tokenMetadata.additionalMetadata, Object.entries(additionalMetadata));
    });
});
(0, node_test_1.describe)("createAccountsMintsAndTokenAccounts", () => {
    (0, node_test_1.test)("createAccountsMintsAndTokenAccounts works", async () => {
        const payer = web3_js_1.Keypair.generate();
        const connection = new web3_js_1.Connection(LOCALHOST);
        await (0, index_1.airdropIfRequired)(connection, payer.publicKey, 100 * web3_js_1.LAMPORTS_PER_SOL, 1 * web3_js_1.LAMPORTS_PER_SOL);
        const SOL_BALANCE = 10 * web3_js_1.LAMPORTS_PER_SOL;
        const usersMintsAndTokenAccounts = await (0, index_1.createAccountsMintsAndTokenAccounts)([
            [1000000000, 0],
            [0, 1000000000], // User 1 has 0 of token A and 1_000_000_000 of token B
        ], SOL_BALANCE, connection, payer);
        // Check all users have been created and have some SOL
        const users = usersMintsAndTokenAccounts.users;
        strict_1.default.equal(users.length, 2);
        await Promise.all(users.map(async (user) => {
            const balance = await connection.getBalance(user.publicKey);
            (0, strict_1.default)(balance === SOL_BALANCE);
        }));
        // Check the mints
        strict_1.default.equal(usersMintsAndTokenAccounts.mints.length, 2);
        // Check the token accounts
        const tokenAccounts = usersMintsAndTokenAccounts.tokenAccounts;
        // Get the balances of the token accounts for the first user
        // (note there is no tokenAccountB balance yet)
        const firstUserFirstTokenBalance = await connection.getTokenAccountBalance(tokenAccounts[0][0]);
        (0, strict_1.default)(Number(firstUserFirstTokenBalance.value.amount) === 1000000000);
        // // Get the balances of the token accounts for the second user
        // // (note there is no tokenAccountA account yet)
        const secondUserSecondTokenBalance = await connection.getTokenAccountBalance(tokenAccounts[1][1]); // Second user, second token mint
        (0, strict_1.default)(Number(secondUserSecondTokenBalance.value.amount) === 1000000000);
    });
});
//# sourceMappingURL=index.test.js.map